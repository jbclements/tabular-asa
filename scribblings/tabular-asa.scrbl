#lang scribble/manual

@require[@for-label[tabular-asa]]

@title{Tabular Asa}
@author[@author+email["Jeffrey Massung" "massung@gmail.com"]]

@defmodule[tabular-asa]

A fast, efficient, dataframes implementation.


@;; ----------------------------------------------------
@section{Sources}

The source code can be found at @url{https://github.com/massung/tabular-asa}.


@;; ----------------------------------------------------
@section{Introduction}

Tabular Asa is intended to fulfill the following goals:

@itemlist[
 @item{Be as efficient as possible sharing memory.}
 @item{Be as lazy as possible; use sequences and streams.}
 @item{Be usable for everyday tabular data tasks.}
 @item{Be extremely simple to understand and extend.}
 @item{Be flexible by exposing low-level functionality.}
 @item{Be a learning example for students who want to learn how to implement databases.}
]

Tabular Asa does this by starting with a couple very simple concepts and building on them. In order, those concepts are:

@itemlist[
 @item{Columns.}
 @item{Tables.}
 @item{Indexing.}
 @item{Grouping.}
 @item{Aggregating.}
]


@;; ----------------------------------------------------
@section{Row vs. Column Major}

When thinking about tabular data, it's very common to think of each row (or record) as a thing to be grouped together. However, this is extremely inefficient for most operations; it requires extracting data from a larger collection into a smaller collection for many operations. It is also an inefficient use of cache. For this reason Tabular Asa is column-major.

A simple example of this difference in implementation would be cutting or inserting columns (a SELECT operation in SQL) to a table. Consider the following table of data:

@code{
| id | name | age | gender |
+----+------+-----+--------|
|  1 | Jeff |  23 |      m |
|  2 |  Sam |  14 |      m |
|  3 | Kate |  38 |      f |
}

When rows are stored as a sequence or hash, removing or adding a column requires duplicating every single row of data and copying it into a new sequence or hash, essentially doubling the memory usage and increasing the time it takes to perform the operation. However, if the table is stored as 3 columns, then creating a new table with a column added only adds the memory cost of the new column. Selecting a subset of columns is even easier.

Additionally, tables contain an a vector which is the index of which rows it sees. This allows for tables that are filters to simply reference the existing column data, but with a new index. In the above example table, the index would be the vector @racket[#(0 1 2)]. If a new table was generated by filtering the original, keeping only the girls, then the new table would contain all the same column data, but the index would be @racket[#(2)].


@;; ----------------------------------------------------
@section{Row vs. Record}

For the purposes of this documentation and function names, a @tt[row] is defined as a @racket[list?] and a @tt[record] is defined as @racket[hash?].


@;; ----------------------------------------------------
@section{Reading Tables}

@defproc[(table-read/sequence [seq (or/c (sequence/c list?)
                                         (sequence/c hash-eq?))]
                              [columns (sequence/c symbol?) '()])
         table?]{
 Creates and returns a new @racket[table] from either a sequence of rows or a sequence of records.
}

@defproc[(table-read/jsexpr [jsexpr jsexpr?]) table?]{
 Given a @racket[jsexpr?] object that is either a list of @racket[jsexpr?] objects or a hash of column values, create and return a new table from the data in the JSON.
}

@defproc[(table-read/csv [port input-port?]
                         [#:header? header boolean? #t]
                         [#:separator-char sep char? #\,]
                         [#:newline newline 'lax]
                         [#:quote-char quote char? #\"]
                         [#:double-quote? double-quote char? #t]
                         [#:comment-char comment char? #\#]
                         [#:strip? strip boolean? #f]
                         [#:na na any #f]
                         [#:na-values na-values list? (list "" "." "na" "n/a" "nan" "null")])
         table?]{
}

@defproc[(table-read/json [port input-port?]
                          [#:orient (or/c 'columns 'records) 'records]
                          [#:lines? lines boolean? #f])
         table?]{
}


@;; ----------------------------------------------------
@section{Tables}

@proc[(table-length [df table?]) exact-nonnegative-integer?]{
 Returns the number of rows in the table.
}

@proc[(table-shape [df table?]) exact-nonnegative-integer? exact-nonnegative-integer?]{
 Returns the number of rows and columns in the table as multiple values.
}

@proc[(table-empty? [df table?]) boolean?]{
 Returns @racket[#t] if there are no rows or no columns in the table.
}

@proc[(table-columns [df table?]) (list/c column?)]{
 Returns a list of columns containing all the data in the table.
}

@proc[(table-column-names [df table?]) (list/c symbol?)]{
 Returns a list of symbols, which are the column names of the table.
}

@proc[(table-column [df table?] [k symbol?]) column?]{
 Looks up the column named @racket[k] and returns it. If a column with that name does not exist, raise an error.
}

@proc[(table-with-column [df table?] 
                         [data sequence?] 
                         [#:as as (or/c symbol? #f) #f]) 
      table?]{
 Returns a new table with either the column data added or replaced if @racket[as] is the same name as an existing column. If no column name is provided then a new column name is generated for it.
}

@proc[(table-with-columns-renamed [df table?] 
                                  [rename-map hash-eq?]) 
      table?]{
 Returns a new table with the columns in @racket[rename-map] renamed. Example:

 @racketblock{
  (table-with-columns-renamed df #hasheq((person . name)))
 }
}

@proc[(table-cut [df table?] 
                 [ks (list/c symbol?)]) 
      table?]{
 Returns a new table with only the columns @racket[ks].
}

@proc[(table-drop [df table?] 
                  [ks (list/c symbol?)]) 
      table?]{
 Returns a new table with the columns @racket[ks] removed.
}

@proc[(table-irow [df table?] 
                  [i exact-nonnegative-integer?]) 
      (list/c any)]{
 Given an index position, return a row (list) of the values in the columns at that position. An index position is the exact index into the column data the table references. This is usually not what you want, but can be useful in some situations.
}

@proc[(table-row [df table?] 
                 [i exact-nonnegative-integer?]) 
      (list/c any)]{
 Given an reference position, return a row (list) of the values in the columns at that position. A reference position is similar to @racket[vector-ref] or @racket[list-ref]: it is the zero-based, nth row within the table.
}

@proc[(table-record [df table?] 
                    [i exact-nonnegative-integer?]) 
      hash-eq?]{
 Given an reference position, return a record (hash) of the columns and values for that row.
}

@proc[(table-records [df table?] 
                     [i exact-nonnegative-integer?]) 
      (sequence/c hash-eq?)]{
 Iterates over the table, returning a record (hash) for each row.
}

@proc[(table-head [df table?] 
                  [n exact-nonnegative-integer? 10]) 
      table?]{
 Returns a new table that is just the first @racket[n] rows of @racket[df].
}

@proc[(table-tail [df table?] 
                  [n exact-nonnegative-integer? 10]) 
      table?]{
 Returns a new table that is just the last @racket[n] rows of @racket[df].
}

@proc[(table-select [df table?] 
                    [flags (sequence/c any/c)]) 
      table?]{
 Given a sequence of boolean values, filters the rows of @racket[df] and returns a new table. Use @racket[table-filter] to filter using a predicate function.
}

@proc[(table-map [proc ((list/c any/c) -> any/c)]
                 [df table?]
                 [ks (or/c (list/c symbol?) #f) #f])
      table?]{
 Provided an optional list of columns, pass a list of those columns to @racket[proc] for every row in @racket[df] and return a lazy sequence of results. If @racket[ks] is @racket[#f] then all columns are used.
}

@proc[(table-apply [proc procedure?]
                   [df table?]
                   [ks (or/c (list/c symbol?) #f) #f])
      table?]{
 Like @racket[table-map], but applies each list of column values to @racket[proc].
}

@proc[(table-filter [proc procedure?]
                    [df table?]
                    [ks (or/c (list/c symbol?) #f) #f])
      table?]{
 Like @racket[table-apply], but the resulting sequence is used for a @racket[table-select]. A new table is returned.
}

@proc[(table-drop-na [df table?]
                     [ks (or/c (list/c symbol?) #f) #f])
      table?]{
 Returns a new table with all rows dropped that have missing values among the columns specified in @racket[ks] (or any column if @racket[ks] is @racket[#f]).
}

@proc[(table-reverse [df table?] table?]{
 Returns a new table with the index order reversed.
}

@proc[(table-sort [df table?]
                  [ks (or/c (list/c symbol?) #f) #f]
                  [less-than? (any/c any/c -> boolean?) sort-ascending]) table?]{
 Returns a new table with the index of @racket[df] sorted by the columns @racket[ks] (or all columns if @racket[#f]) sorted by @racket[less-than?]. By default, it will sort in ascending order using a custom sorting function.
}

@proc[(table-distinct [df table?]
                      [ks (or/c (list/c symbol?) #f) #f]
                      [keep (or/c 'first 'last 'none) 'first]){
 Returns a new table removing duplicate rows where all the columns specified in @racket[ks] are @racket[equal?].
}


@;; ----------------------------------------------------
@section{Columns}


@;; ----------------------------------------------------
@section{Indexes}


@;; ----------------------------------------------------
@section{Groups}

