#lang scribble/manual

@require[@for-label[tabular-asa]]

@title{Tabular Asa}
@author[@author+email["Jeffrey Massung" "massung@gmail.com"]]

@defmodule[tabular-asa]

A fast, efficient, dataframes implementation.


@;; ----------------------------------------------------
@section{Sources}

The source code can be found at @url{https://github.com/massung/tabular-asa}.


@;; ----------------------------------------------------
@section{Introduction}

Tabular Asa is intended to fulfill the following goals:

@itemlist[
 @item{Be as efficient as possible sharing memory.}
 @item{Be as lazy as possible; use sequences and streams.}
 @item{Be usable for everyday tabular data tasks.}
 @item{Be extremely simple to understand and extend.}
 @item{Be flexible by exposing low-level functionality.}
 @item{Be a learning example for students who want to learn how to implement databases.}
]

Tabular Asa does this by starting with a couple very simple concepts and building on them. In order, those concepts are:

@itemlist[
 @item{Columns.}
 @item{Tables.}
 @item{Indexing.}
 @item{Grouping.}
 @item{Aggregating.}
]


@;; ----------------------------------------------------
@section{Row vs. Column Major}

When thinking about tabular data, it's very common to think of each row (or record) as a thing to be grouped together. However, this is extremely inefficient for most operations; it requires extracting data from a larger collection into a smaller collection for many operations. It is also an inefficient use of cache. For this reason Tabular Asa is column-major.

A simple example of this difference in implementation would be cutting or inserting columns (a SELECT operation in SQL) to a table. Consider the following table of data:

@tabular[#:style 'boxed
         #:column-properties '(left left left)
         #:row-properties '(bottom-border () () ())
         (list (list @bold{name} @bold{age} @bold{gender})
               (list "Jeff" "23" "m")
               (list "Sam" "14" "m")
               (list "Kate" "38" "f"))]

When rows are stored as a sequence or hash, removing or adding a column requires duplicating every single row of data and copying it into a new sequence or hash, essentially doubling the memory usage and increasing the time it takes to perform the operation. However, if the table is stored as 3 columns, then creating a new table with a column added only adds the memory cost of the new column. Selecting a subset of columns is even easier.

Additionally, tables contain an a vector which is the index of which rows it sees. This allows for tables that are filters to simply reference the existing column data, but with a new index. In the above example table, the index would be the vector @racket[#(0 1 2)]. If a new table was generated by filtering the original, keeping only the girls, then the new table would contain all the same column data, but the index would be @racket[#(2)].


@;; ----------------------------------------------------
@section{Row vs. Record}

For the purposes of this documentation and function names, a row is defined as a @racket[list?] and a record is defined as @racket[hash?].


@;; ----------------------------------------------------
@section{Reading Tables}

It is important to note that - when reading tables - columns that don't already exist will be generated on-demand. The column names will be equivelant to calling @racket[(gensym "col")] to ensure they are unique symbols.

@defproc[(table-read/sequence [seq (or/c (listof any/c)
                                         (sequenceof hash-eq?))]
                              [columns (sequenceof symbol?) '()])
         table?]{
 Creates and returns a new @racket[table] from either a sequence of rows or a sequence of records.
}

@defproc[(table-read/jsexpr [jsexpr jsexpr?]) table?]{
 Given a @racket[jsexpr?], use the shape of the object to determine how it should be transformed into a table.

 If @racket[jsexpr] is a JSON object (@racket[hash-eq?]), then it is assumed to be a 
}

@defproc[(table-read/csv [port input-port?]
                         [#:header? header boolean? #t]
                         [#:separator-char sep char? #\,]
                         [#:quote-char quote char? #\"]
                         [#:double-quote? double-quote char? #t]
                         [#:comment-char comment char? #\#]
                         [#:strip? strip boolean? #f]
                         [#:na na any/c #f]
                         [#:na-values na-values (listof string?) (list "" "." "na" "n/a" "nan" "null")])
         table?]{
 Reads the data in @racket[port] as a CSV file using the options specified and returns a new @racket[table]. Most of the arguments are used for parsing the CSV.

 The @racket[header] argument - if @racket[#t] - indicates that the first non-comment row of the CSV should be treated as the list of column names. If false then the column names will be generated as needed.

 The @racket[na-values] argument is a list of strings that - when parsed as the value for a given cell - are replaced with the @racket[na] value to indicate N/A (not available). The values in this list are case-insensitive.
}

@defproc[(table-read/json [port input-port?]
                          [#:lines? lines boolean? #f])
         table?]{
 Reads the data in @racket[port] as a JSON value. If @racket[lines] is @racket[#t] then the @racket[port] is read line-by-line and assumed to be a JSON object (@racket[hash-eq?]) corresponding to a single record of the resulting table. Otherwise the entire JSON object is read into memory and passed to @racket[table-read/jsexpr].
}


@;; ----------------------------------------------------
@section{Tables}

@defstruct[table ([index (vectorof exact-nonnegative-integer?)]
                  [data (listof (cons/c symbol? (vectorof any/c)))])]{
 The constructor for a new table structure. There should almost never be a need to call this directly as opposed to using one of the table-read/* functions to load a table from another container or a port.

 All tables are also sequences and can be iterated using @racket[for], where each iteration returns the next row (list). For example:

 @racketblock[
  (define df (table #(0 1 2) '((hero . #("Superman" "Batman" "Wonder Woman"))
                               (gender . #(m m f)))))
  (for ([row df])
    (displayln row))
 ]
}

@defthing[empty-table table?]{
 An immutable, empty table. Useful for building a table from scratch using @racket[table-with-column] or returning from a function in failure cases, etc.
}

@defproc[(table-length [df table?]) exact-nonnegative-integer?]{
 Returns the number of rows in the table.
}

@defproc[(table-shape [df table?]) exact-nonnegative-integer?]{
 Returns the number of rows and columns in the table as multiple values.
}

@defproc[(table-empty? [df table?]) boolean?]{
 Returns @racket[#t] if there are no rows or no columns in the table.
}

@defproc[(table-columns [df table?]) (listof column?)]{
 Returns a list of columns containing all the data in the table.
}

@defproc[(table-column-names [df table?]) (listof symbol?)]{
 Returns a list of symbols, which are the column names of the table.
}

@defproc[(table-column [df table?] [k symbol?]) column?]{
 Looks up the column named @racket[k] and returns it. If a column with that name does not exist, raise an error.
}

@defproc[(table-with-column [df table?] 
                            [data sequence?] 
                            [#:as as (or/c symbol? #f) #f]) 
         table?]{
 Returns a new table with either the column data added or replaced if @racket[as] is the same name as an existing column. If no column name is provided then a new column name is generated for it.
}

@defproc[(table-with-columns-renamed [df table?] 
                                     [rename-map hash-eq?]) 
         table?]{
 Returns a new table with the columns in @racket[rename-map] renamed. Example:

 @racketblock{
  (table-with-columns-renamed df #hasheq((person . name)))
 }
}

@defproc[(table-cut [df table?] 
                    [ks (listof symbol?)]) 
         table?]{
 Returns a new table with only the columns @racket[ks].
}

@defproc[(table-drop [df table?] 
                     [ks (listof symbol?)]) 
         table?]{
 Returns a new table with the columns @racket[ks] removed.
}

@defproc[(table-irow [df table?] 
                     [i exact-nonnegative-integer?]) 
         (listof any/c)]{
 Given an index position, return a row (list) of the values in the columns at that position. An index position is the exact index into the column data the table references. This is usually not what you want, but can be useful in some situations.
}

@defproc[(table-row [df table?] 
                    [i exact-nonnegative-integer?]) 
         (list/c any/c)]{
 Given an reference position, return a row (list) of the values in the columns at that position. A reference position is similar to @racket[vector-ref] or @racket[list-ref]: it is the zero-based, nth row within the table.
}

@defproc[(table-record [df table?] 
                       [i exact-nonnegative-integer?]) 
         hash-eq?]{
 Given an reference position, return a record (hash) of the columns and values for that row.
}

@defproc[(table-records [df table?] 
                        [i exact-nonnegative-integer?]) 
         (sequenceof hash-eq?)]{
 Iterates over the table, returning a record (hash) for each row.
}

@defproc[(table-head [df table?] 
                     [n exact-nonnegative-integer? 10]) 
      table?]{
 Returns a new table that is just the first @racket[n] rows of @racket[df].
}

@defproc[(table-tail [df table?] 
                     [n exact-nonnegative-integer? 10]) 
      table?]{
 Returns a new table that is just the last @racket[n] rows of @racket[df].
}

@defproc[(table-select [df table?] 
                       [flags (sequenceof any/c)]) 
      table?]{
 Given a sequence of boolean values, filters the rows of @racket[df] and returns a new table. Use @racket[table-filter] to filter using a predicate function.
}

@defproc[(table-map [proc ((listof any/c) -> any/c)]
                    [df table?]
                    [ks (or/c (listof symbol?) #f) #f])
      table?]{
 Provided an optional list of columns, pass a list of those columns to @racket[proc] for every row in @racket[df] and return a lazy sequence of results. If @racket[ks] is @racket[#f] then all columns are used.
}

@defproc[(table-apply [proc procedure?]
                      [df table?]
                      [ks (or/c (listof symbol?) #f) #f])
      table?]{
 Like @racket[table-map], but applies each list of column values to @racket[proc].
}

@defproc[(table-filter [proc procedure?]
                       [df table?]
                       [ks (or/c (listof symbol?) #f) #f])
      table?]{
 Like @racket[table-apply], but the resulting sequence is used for a @racket[table-select]. A new table is returned.
}

@defproc[(table-drop-na [df table?]
                        [ks (or/c (listof symbol?) #f) #f])
      table?]{
 Returns a new table with all rows dropped that have missing values among the columns specified in @racket[ks] (or any column if @racket[ks] is @racket[#f]).
}

@defproc[(table-reverse [df table?]) table?]{
 Returns a new table with the index order reversed.
}

@defproc[(table-sort [df table?]
                     [ks (or/c (listof symbol?) #f) #f]
                     [less-than? (any/c any/c -> boolean?) sort-ascending]) table?]{
 Returns a new table with the index of @racket[df] sorted by the columns @racket[ks] (or all columns if @racket[#f]) sorted by @racket[less-than?]. By default, it will sort in ascending order using a custom sorting predicate.
}

@defproc[(table-distinct [df table?]
                         [ks (or/c (listof symbol?) #f) #f]
                         [keep (or/c 'first 'last 'none) 'first])
         table?]{
 Returns a new table removing duplicate rows where all the columns specified in @racket[ks] are @racket[equal?].
}


@;; ----------------------------------------------------
@section{Columns}

@defstruct[column ([name symbol?]
                   [index (vectorof exact-nonnegative-integer?)]
                   [data (vectorof any/c)])]{
 The constructor for a new column. There should almost never be a need to call this directly as opposed to having one created for you using the @racket[table-column] function, which shares the same index and data values for the table. All columns are also sequences and can be iterated using @racket[for].
}

@defthing[empty-column column?]{
 The immutable empty column.
}

@defproc[(build-column [data (sequenceof any/c)]
                       [#:as as (or/c symbol? #f) #f])
         column?]{
 Builds a new column with the values in @racket[data]. The data is copied and a new index is built for the column. If @racket[#:as] is @racket[#f] then a unique column name will be generated for it.
}

@defproc[(column-length [col column?]) exact-nonnegative-integer?]{
 Returns the number of data items referenced by the index.
}

@defproc[(column-empty? [col column?]) boolean?]{
 Returns @racket[#t] if the column's index is empty.
}

@defproc[(column-compact [col column?]) column?]{
 Returns a new column with duplicated, but (presumably) reduced data and memory usage. This is useful if the original column contains lots of data, but a very small index.
}

@defproc[(column-rename [col column?]
                        [as (or/c symbol? #f) #f]) column?]{
 Returns a new column, referencing the same data as @racket[col], but with a different name. If @racket[as] is not provided, then a unique colum name will be generated.
}

@defproc[(column-ref [col column?]
                     [n exact-nonnegative-integer?])
         any/c]{
 Returns the nth item from the indexed data in the column.
}

@defproc[(column-head [col column?]
                      [n exact-nonnegative-integer? 10])
         column?]{
 Returns a new column that shares data with @racket[col], but only contains the first @racket[n] items.
}

@defproc[(column-tail [col column?]
                      [n exact-nonnegative-integer? 10])
         column?]{
 Returns a new column that shares data with @racket[col], but only contains the last @racket[n] items.
}

@defproc[(column-reverse [col column?]) column?]{
 Returns a new column that shares data with @racket[col], but with the index reversed.
}

@defproc[(column-sort [col column?]
                      [less-than? ((any/c any/c) -> boolean?) sort-ascending]) column?]{
 Returns a new column that shares data with @racket[col], but with the index sorted by the data values.
}

@;; ----------------------------------------------------
@section{Indexes}

@defstruct[index ([keys (vectorof (list/c any/c exact-nonnegative-integer? ...))]
                  [less-than? (or/c ((any/c any/c) -> boolean?) #f)])]{
 Constructor for a new index. The @racket[keys] are a sorted vector of lists, where the first element of the list is the key value and the rest of the list are indices. The @racket[less-than?] predicate is the same as was used to sort @racket[keys] before passing them in.
}

@defproc[(build-index [data (sequenceof any/c)]
                      [less-than? (or/c ((any/c any/c) -> boolean?) #f) sort-ascending])
         index?]{
 Creates a new index by finding all the unique keys in the @racket[data] sequence along with the ordered indices where they keys are located, then sorts them using the @racket[less-than?] predicate if defined. If the @racket[less-than?] predicate function is @racket[#f] then no sorting takes place and the keys are in a random order.
}

@defthing[empty-index index?]{
 An empty index.
}

@defproc[(index-scan-keys [ix index?]
                          [#:from from any/c #f]
                          [#:to to any/c #f])
         sequence?]{
 Returns a sequence from the @racket[from] key (inclusive) to the @racket[to] key (exclusive). If @racket[from] is @racket[#f] then the sequence begins with the first key. If @racket[to] is @racket[#f] then the sequence ends with the last key in the index. The sequence returns multiple values: the key and a list of all the reference indices of the data sequence where the keys originated from.
 
 If the index is not sorted then the order of the sequence returned is undefined.
}

@defproc[(index-scan [ix index?]
                     [#:from from any/c #f]
                     [#:to to any/c #f])
         sequence?]{
 Similar to @racket[index-scan-keys], but instead of the sequence returning multiple values, this sequence only returns the indices, in order.
}

@defproc[(index-length [ix index?]) exact-nonnegative-integer?]{
 Returns the number of unique keys in the index.
}

@defproc[(index-empty? [ix index?]) boolean?]{
 True if the index has no keys.
}

@defproc[(index-sorted? [ix index?]) boolean?]{
 True if the index was defined with a less-than? predicate. 
}

@defproc[(index-find [ix index?]
                     [key any/c]
                     [exact boolean? #f])
         (or/c exact-nonnegative-integer? #f)]{
 Searches the index looking for a matching @racket[key]. If the index is sorted then this is a binary search, otherwise it's a linear search through all the keys for a match. 

 If @racket[key] is found, then the reference index to the keys is returned. When not found, if @racket[exact] is @racket[#t] then @racket[#f] is returned. Otherwise, the next higher index for the next key is returned.
}

@defproc[(index-member [ix index?]
                       [key any/c])
         (or/c (list/c any/c exact-nonnegative-integer? ...) #f)]{
 Searches the index looking for an exactly matching @racket[key]. If found then the list of key and indices is returned, otherwise @racket[#f] is returned.
}

@defproc[(index-ref [ix index?]
                    [n exact-nonnegative-integer?])
         (list/c any/c exact-nonnegative-integer? ...)]{
 Returns the key and indices at the given reference index.
}

@defproc[(index-map [ix index?]
                    [v (vectorof any/c)]
                    [#:from from any/c #f]
                    [#:to to any/c #f])
         sequence?]{
 Scans the index and maps the indices across the values in @racket[v] and returns them in a new sequence.
}

@defproc[(index-min [ix index?]) (or/c any/c #f)]{
 Returns @racket[#f] if the index is empty, otherwise returns the first key in the index.
}

@defproc[(index-max [ix index?]) (or/c any/c #f)]{
 Returns @racket[#f] if the index is empty, otherwise returns the last key in the index.
}

@defproc[(index-median [ix index?]) (or/c any/c #f)]{
 Returns @racket[#f] if the index is empty, otherwise returns the median key in the index.
}

@defproc[(index-mode [ix index?]) (or/c any/c #f)]{
 Returns @racket[#f] if the index is empty, otherwise returns the key that occurs the most often.
}


@;; ----------------------------------------------------
@section{Groups}

